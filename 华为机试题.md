# 华为机试题

## 1. 取近似值

```java
import java.util.*;
import java.lang.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        Double num = scanner.nextDouble();
        //System.out.println((int)(num + 0.5));
        System.out.println(Math.round(num));
    }
}
```

## 2.求int型正整数在内存中存储时1的个数

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        int num = scanner.nextInt();
        int result = 0;
        while(num > 1){
            if(num%2 == 1){
                result++;
            }
            num = num /2;
        }
        if(num == 1){
            result ++;
        }
        System.out.println(result);
    }
}
```

## 3.数字颠倒

```java
import java.util.*;
import java.lang.*;
public class Main{
   public static void main(String[] args){
       Scanner scanner = new Scanner(System.in);
       int num = scanner.nextInt();
       StringBuffer stringbuffer = new StringBuffer();
       stringbuffer.append(String.valueOf(num));
       System.out.println(stringbuffer.reverse());
   }
}
```

## 4.字符串反转

```java
import java.lang.*;
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        StringBuffer stringbuffer = new StringBuffer(scanner.next());
        System.out.println(stringbuffer.reverse());
    }
}
```

## 5.汽水瓶

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        int num = 0;
        while((num = scanner.nextInt()) != 0){
            int result = 0;
            int floag = 0;
            while(num > 2){
                floag = num/3;
                result += floag;
                num = num%3 + floag;
            }
            if(num == 2){
                result ++;
            }
            System.out.println(result);
        }
    }
}
```

## 6.统计每个月兔子的总数

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNextInt()){
            int month = scanner.nextInt();
            int[] result = new int[month];
            for(int i=0;i<month;i++){
                if(i == 0 || i == 1){
                    result[i] = 1;
                }else{
                    result[i] = result[i-2] + result[i-1];
                }
            }
            System.out.println(result[month-1]);
        }
    }
}
```

## 7.四则运算

```java

import java.util.*;
// 第一步，先考虑无括号的情况，先乘除后加减，这个用栈很容易解决，遇到数字先压栈，如果下一个是乘号或除号，先出栈，和下一个数进行乘除运算，再入栈，
// 最后就能保证栈内所有数字都是加数，最后对所有加数求和即可。
// 第二步，遇到左括号，直接递归执行第一步即可，最后检测到右括号，返回括号内的计算结果，退出函数，这个结果作为一个加数，返回上一层入栈。
public class Main{
    public static void  main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNext()){
            String s =scanner.nextLine();
            int pos = 0;
            System.out.println(getInnerResult(s));
        }
    }
    static int pos;
    //递归，消消乐，算括号里面的(无括号的)数字的结果
    public static int getInnerResult(String s){
        Stack<Integer> val = new Stack<>();
        int num = 0;
        char opt = '+';
        while(pos < s.length()){
            //遇到括号，开始递归 ，从括号里面开始算，消消乐
            if(s.charAt(pos) == '{' || s.charAt(pos) == '[' || s.charAt(pos) == '('){
                pos ++;
                num = getInnerResult(s);
            }

            //得到数字num
            while(pos < s.length() && Character.isDigit(s.charAt(pos))){
                //这步操作是 num是几位就得到几位的num。
                num = num * 10 + s.charAt(pos) - '0';
                pos ++;
            }

            //按照题目意思，正常合法的表达式字符串的话，数字后面一定会是跟运算符。
            //所以这里判断运算符
            //这一步的终极目的是把栈里面全部变成+ 号的运算，
            switch (opt){
                case '+':
                    val.push(num);
                    break;
                //- 号的时候变成负数
                case '-':
                    val.push(-num);
                    break;
                //乘号的时候出栈先做乘法运算后把得到的结果 再入栈
                case '*':
                    val.push(val.pop()*num);
                    break;
                //同上面的乘号
                case '/':
                    val.push(val.pop()/num);
                    break;
            }
            num =0;
            if(pos < s.length()){
                //数字后面有可能是运算符或者括号
                //如果下面没有被break，这里opt是取得的下一个运算符
                opt = s.charAt(pos);
                //如果这里是括号，就break，那么opt的值会在一开始被初始化成+
                if(s.charAt(pos) == '}' || s.charAt(pos) == ']' || s.charAt(pos) == ')'){
                    pos ++;
                    break;
                }
            }
            pos ++;
        }
        int sum = 0;
        while(!val.empty()){
            sum += val.pop();
        }
        return sum;
    }
}
```

## 8.杨辉三角的变形

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNextInt()){
            int row = scanner.nextInt();
            int[][] rowData = new int[row][2*row-1];
            rowData[0][0] = 1;
            rowData[1][0] = 1;
            rowData[1][1] = 1;
            rowData[1][2] = 1;
            for(int i=2;i<row;i++){
                for(int j = 0;j<2*i-1;j++){
                    if(j == 0){
                        rowData[i][j] = 1;
                    } else
                    if(j == 1){
                        rowData[i][j] = rowData[i-1][0] + rowData[i-1][1];
                    } else
                    if(j == row){
                        rowData[i][j] = rowData[i-1][j-2] + rowData[i-1][j-1];
                    } else
                    if(j == row+1){
                        rowData[i][j] = rowData[i-1][j-2];
                    } else
                    rowData[i][j] = rowData[i-1][j] + rowData[i-1][j-1] + rowData[i-1][j-2];
                }
            }
            int result = -1;
            for(int i=0;i<rowData[row-1].length;i++){
                if(rowData[row-1][i] % 2 == 0){
                    result = i + 1;
                    break;
                }
            }
            System.out.println(result);
        }
    }
}
```

## 9.完全数计算

```java
import java.util.*;

public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNextInt()){
            int num = scanner.nextInt();
            if(num < 6){
                System.out.println(0);
                continue;
            }
            int count = 0;
            for(int i=6;i<=num;i++){
                int sum = 0;
                for(int j=1;j<=i/2;j++){
                    if(i%j == 0){
                        sum += j;
                    }
                }
                if(sum == i){
                    count ++;
                }
            }
            System.out.println(count);
        }
    }
}
```

## 10.*放苹果

> 题目描述:
>
> 把m个同样的苹果放在n个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用K表示）5，1，1和1，5，1 是同一种分法。
>
> 数据范围：0<=m<=10，1<=n<=10。
>
> 本题含有多组样例输入。
>
> ## 示例1
>
> 输入：
>
> ```
> 7 3
> ```
>
> 复制
>
> 输出：
>
> ```
> 8
> ```

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNextInt()){
            int m = scanner.nextInt();
            int n = scanner.nextInt();
            int result = -1;
            if(n>=1 && n <=10 && m >=1 && m <=10){
                result = getCount(m,n);
            }
            System.out.println(result);
        }
    }
    public static int getCount(int m,int n){
        if(m == 0 || n == 1) 
            return 1;
        if(n > m)
            return getCount(m,m);
        return getCount(m,n-1) + getCount(m-n,n);
    }
}
```

## 11.查找输入整数二进制中1的个数

> 
> 输入一个正整数，计算它在二进制下的1的个数。
>
> **注意多组输入输出！！！！！！
> **
>
> ### 输入描述：
>
> 输入一个整数
>
> ### 输出描述：
>
> 计算整数二进制中1的个数
>
> ## 示例1
>
> 输入：
>
> ```
> 5
> ```
>
> 复制
>
> 输出：
>
> ```
> 2
> ```
>
> 复制
>
> 说明：
>
> ```
> 5的二进制表示是101，有2个1 
> ```

```java
import java.util.*;
import java.lang.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNextInt()){
            int num = scanner.nextInt();
            int count = 0;
            while(num > 1){
                if(num%2 == 1){
                    count++;
                }
                num = num/2;
                
            }
            if(num == 1){
                count++;
            }
            System.out.println(count);
        }
    }
}
```

## 12.配置文件恢复

> ## 描述
>
> 有6条配置命令，它们执行的结果分别是：
>
> | **命  令**           | **执  行**      |
> | -------------------- | --------------- |
> | **reset**            | reset what      |
> | **reset board**      | board fault     |
> | **board add**        | where to add    |
> | **board delete**     | no board at all |
> | **reboot backplane** | impossible      |
> | **backplane abort**  | install first   |
> | ***he he***          | unknown command |
>
> **注意：he he不是命令。**
>
> 为了简化输入，方便用户，以“最短唯一匹配原则”匹配：
> 1、若只输入一字串，则只匹配一个关键字的命令行。例如输入：r，根据该规则，匹配命令reset，执行结果为：reset what；输入：res，根据该规则，匹配命令reset，执行结果为：reset what；
> 2、若只输入一字串，但本条命令有两个关键字，则匹配失败。例如输入：reb，可以找到命令reboot backpalne，但是该命令有两个关键词，所有匹配失败，执行结果为：unknown command
> 3、若输入两字串，则先匹配第一关键字，如果有匹配但不唯一，继续匹配第二关键字，如果仍不唯一，匹配失败。例如输入：r b，找到匹配命令reset board 和 reboot backplane，执行结果为：unknown command。
>
> 4、若输入两字串，则先匹配第一关键字，如果有匹配但不唯一，继续匹配第二关键字，如果唯一，匹配成功。例如输入：b a，无法确定是命令**board add**还是**backplane abort**，匹配失败。
> 5、若输入两字串，第一关键字匹配成功，则匹配第二关键字，若无匹配，失败。例如输入：bo a，确定是命令**board add**，匹配成功。
> 6、若匹配失败，打印“unknown command”
>
> 
>
> ### 输入描述：
>
> 多行字符串，每行字符串一条命令
>
> ### 输出描述：
>
> 执行结果，每条命令输出一行
>
> ## 示例1
>
> 输入：
>
> ```
> reset
> reset board
> board add
> board delet
> reboot backplane
> backplane abort
>  
> ```
>
> 复制
>
> 输出：
>
> ```
> reset what
> board fault
> where to add
> no board at all
> impossible
> install first
>  
> ```

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;
import java.lang.*;
public class Main{
    public static void main(String[] args) throws IOException {
        Map<String,String> map = new HashMap<String,String>();
        String commandNotFound = "unknown command";
        map.put("reset board","board fault");
        map.put("board add","where to add");
        map.put("board delete","no board at all");
        map.put("reboot backplane","impossible");
        map.put("backplane abort","install first");
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNextLine()){
            String lineString = scanner.nextLine();
            String[] strs = lineString.split(" ");
            if(strs.length > 1){
                List<String> sList = new ArrayList();
                for(String s : map.keySet()){
                    String[] ss = s.split(" ");
                    if(ss[0].startsWith(strs[0]) && ss[1].startsWith(strs[1])){
                        sList.add(s);
                    }
                }
                if(sList.size() == 1){
                    System.out.println(map.get(sList.get(0)));
                }else{
                    System.out.println(commandNotFound);
                }
            }else{
                if("reset".startsWith(lineString)){
                    System.out.println("reset what");
                }else{
                    System.out.println(commandNotFound);
                }
            }
        }
    }
}
```

## 13.百钱买百鸡问题

> ## 描述
>
> 公元前五世纪，我国古代数学家张丘建在《算经》一书中提出了“百鸡问题”：鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？
>
> 详细描述：
>
> 接口说明
>
> 原型：
>
> int GetResult(vector &list)
>
> 输入参数：
>
> ​    无
>
> 输出参数（指针指向的内存区域保证有效）：
>
>   list 鸡翁、鸡母、鸡雏组合的列表
>
> 返回值：
>
>    -1 失败   
>
>    0 成功
>
> ### 输入描述：
>
> 输入任何一个整数，即可运行程序。
>
> ### 输出描述：
>
>  
>
> ## 示例1
>
> 输入：
>
> ```
> 1
> ```
>
> 复制
>
> 输出：
>
> ```
> 0 25 75
> 4 18 78
> 8 11 81
> 12 4 84
> ```

```java
import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int sum = scanner.nextInt();
            for (int i = 0; i < 100; i++) {
                for (int j = 0; j < 34; j++) {
                    if (i + 9 * j + 15 * (100 - i - j) == 300 && (100 - i - j) >= 0) {
                        System.out.println((100 - i - j) + " " + j + " " + i);
                    }
                }
            }
    }
}
```

## 14.计算日期到天数转换

> ## 描述
>
> 根据输入的日期，计算是这一年的第几天。
>
> ### 输入描述：
>
> 输入一行，每行空格分割，分别是年，月，日
>
> ### 输出描述：
>
> 输出是这一年的第几天
>
> ## 示例1
>
> 输入：
>
> ```
> 2012 12 31
> ```
>
> 复制
>
> 输出：
>
> ```
> 366
> ```
>
> 复制
>
> ## 示例2
>
> 输入：
>
> ```
> 1982 3 4
> ```
>
> 复制
>
> 输出：
>
> ```
> 63
> ```

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNextInt()){
            int year = scanner.nextInt();
            int month = scanner.nextInt();
            int day = scanner.nextInt();
            boolean isRun = year%4 == 0 && year%100 != 0;
            int dayCount = 0;
            for(int i=1;i<month; i++){
               if(i == 1 || i == 3|| i == 5|| i == 7|| i == 8|| i == 10|| i == 12){
                   dayCount += 31;
               }else if (i == 4 || i == 6||  i == 9|| i == 11){
                   dayCount += 30;
               }else{
                   if(isRun) {
                       dayCount += 29;
                   }else{
                       dayCount += 28;
                   }
               }
            }
            System.out.println(dayCount + day);
        }
    }
}
```

## 15.参数解析

> ## 描述
>
> 在命令行输入如下命令：
>
> xcopy /s c:\ d:\，
>
> 各个参数如下：
>
> 参数1：命令字xcopy
>
> 参数2：字符串/s
>
> 参数3：字符串c:\
>
> 参数4: 字符串d:\
>
> 请编写一个参数解析程序，实现将命令行各个参数解析出来。
>
> 解析规则：
>
> 1.参数分隔符为空格
> 2.对于用""包含起来的参数，如果中间有空格，不能解析为多个参数。比如在命令行输入xcopy /s "C:\program files" "d:\"时，参数仍然是4个，第3个参数应该是字符串C:\program files，而不是C:\program，注意输出参数时，需要将""去掉，引号不存在嵌套情况。
> 3.参数不定长
> 4.输入由用例保证，不会出现不符合要求的输入
>
> ### 输入描述：
>
> 输入一行字符串，可以有空格
>
> ### 输出描述：
>
> 输出参数个数，分解后的参数，每个参数都独占一行
>
> ## 示例1
>
> 输入：
>
> ```
> xcopy /s c:\\ d:\\
> ```
>
> 复制
>
> 输出：
>
> ```
> 4
> xcopy
> /s
> c:\\
> d:\\
> ```

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNextLine()){
            String lineStr = scanner.nextLine();
            String[] result = lineStr.split(" ");
            int rowCount = 0;
            String tempStr = "";
            List<String> list = new ArrayList();
            for(int i=0;i<result.length;i++){
                  if(tempStr == "" && !result[i].contains("\"")){
                      rowCount++;
                      list.add(result[i]);
                  }else{
                      if(tempStr == ""){
                          tempStr = result[i];
                          if(tempStr.startsWith("\"") && tempStr.endsWith("\"")){
                              list.add(tempStr.replaceAll("\"",""));
                              tempStr = "";
                          }
                      }else if(tempStr.contains("\"") && result[i].contains("\"")){
                          tempStr = tempStr + " " + result[i];
                          list.add(tempStr.replaceAll("\"",""));
                          tempStr = "";
                      }else{
                          tempStr = tempStr + " " + result[i];
                      }
                      
                  }
            }
            System.out.println(list.size());
            for(String s : list){
                System.out.println(s);
            }
        }
    }
}
```

## 16.公共子串计算

> ## 描述
>
> 给定两个只包含小写字母的字符串，计算两个字符串的最大公共子串的长度。
>
> 注：子串的定义指一个字符串删掉其部分前缀和后缀（也可以不删）后形成的字符串。
>
> ### 输入描述：
>
> 输入两个只包含小写字母的字符串
>
> ### 输出描述：
>
> 输出一个整数，代表最大公共子串的长度
>
> ## 示例1
>
> 输入：
>
> ```
> asdfas
> werasdfaswer
> ```
>
> 复制
>
> 输出：
>
> ```
> 6
> ```

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNext()){
            String str1 = scanner.next();
            String str2 = scanner.next();
            int maxint = 0;
            for(int i=0;i<str1.length();i++){
                for(int j=i+1;j<str1.length();j++){
                   String str = str1.substring(i,j);
                   if(str2.contains(str)){
                       if(str.length() > maxint){
                           maxint = str.length();
                       }
                   }
                }
            }
            System.out.println(maxint);
        }
    }
}
```

## 17.尼科彻斯定理

> ## 描述
>
> 验证尼科彻斯定理，即：任何一个整数m的立方都可以写成m个连续奇数之和。
>
> 例如：
>
> 1^3=1
>
> 2^3=3+5
>
> 3^3=7+9+11
>
> 4^3=13+15+17+19
>
> 输入一个正整数m（m≤100），将m的立方写成m个连续奇数之和的形式输出。
>
> 本题含有多组输入数据。
>
> 
>
> ### 输入描述：
>
> 输入一个int整数
>
> ### 输出描述：
>
> 输出分解后的string
>
> ## 示例1
>
> 输入：
>
> ```
> 6
> ```
>
> 复制
>
> 输出：
>
> ```
> 31+33+35+37+39+41
> ```

```java
import java.util.*;

public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNextInt()){
            int num = scanner.nextInt();
            int param1 = num * num;
            int param2 = num * num * num;
            int param3 = 0;
            boolean floag = num%2 == 0;
            if(floag){
                param3 = num / 2;
            }else{
                param3 = (num-1)/2;
            }
            List<Integer> intList = new ArrayList<Integer>();
            int count = 0;
            for(int i=param1-1;;i--){
                if(i%2 == 1){
                    intList.add(i);
                    count++;
                    if(count == param3){
                        break;
                    }
                }
            }
            count = 0;
            for(int i=param1+1;;i++){
                if(i%2 == 1){
                    intList.add(i);
                    count++;
                    if(count == param3){
                        break;
                    }
                }
            }
            if(!floag){
                intList.add(param1);
            }
            Integer[] intArray = intList.toArray(new Integer[0]);
            Arrays.sort(intArray);
            StringBuffer stringbuffer = new StringBuffer();
            for(int i=0;i<intArray.length;i++){
                stringbuffer.append(intArray[i] + "+");
            }
            stringbuffer.deleteCharAt(stringbuffer.length()-1);
            System.out.println(stringbuffer.toString());
        }
    }
}
```

## 18.二维数组操作

> ## 描述
>
> 有一个![img](https://www.nowcoder.com/equation?tex=m*n%5C)大小的数据表，你会依次进行以下5种操作：
>
> 1.输入![img](https://www.nowcoder.com/equation?tex=m%5C)和![img](https://www.nowcoder.com/equation?tex=n%5C)，初始化![img](https://www.nowcoder.com/equation?tex=m*n%5C)大小的表格。
>
> 2.输入x_1*x*1、y_1*y*1、x_2*x*2、y_2*y*2，交换坐标在(x_1,y_1)(*x*1,*y*1)和(x_2,y_2)(*x*2,*y*2)的两个数。
>
> 3.输入![img](https://www.nowcoder.com/equation?tex=x%5C)，在第![img](https://www.nowcoder.com/equation?tex=x%5C)行上方添加一行。
>
> 4.输入![img](https://www.nowcoder.com/equation?tex=y%5C)，在第![img](https://www.nowcoder.com/equation?tex=y%5C)列左边添加一列。
>
> 5.输入![img](https://www.nowcoder.com/equation?tex=x%5C)、![img](https://www.nowcoder.com/equation?tex=y%5C)，查找坐标为![img](https://www.nowcoder.com/equation?tex=(x%2Cy)%5C)的单元格的值。
>
> 请编写程序，判断对表格的各种操作是否合法。
>
> 详细要求:
>
> 1.数据表的最大规格为9行*9列，对表格进行操作时遇到超出规格应该返回错误。
>
> 2.对于插入操作，如果插入后行数或列数超过9了则应返回错误。如果插入成功了则将数据表恢复至初始化的![img](https://www.nowcoder.com/equation?tex=m*n%5C)大小，多出的数据则应舍弃。
>
> 3.所有输入坐标操作，对![img](https://www.nowcoder.com/equation?tex=m*n%5C)大小的表格，行号坐标只允许0~m-1，列号坐标只允许0~n-1。超出范围应该返回错误。
>
> 本题含有多组样例输入！
>
> ### 输入描述：
>
> 输入数据按下列顺序输入：
> 1 表格的行列值
> 2 要交换的两个单元格的行列值
> 3 输入要插入的行的数值
> 4 输入要插入的列的数值
> 5 输入要查询的单元格的坐标
>
> ### 输出描述：
>
> 输出按下列顺序输出：
> 1 初始化表格是否成功，若成功则返回0， 否则返回-1
> 2 输出交换单元格是否成功
> 3 输出插入行是否成功
> 4 输出插入列是否成功
> 5 输出查询单元格数据是否成功

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNext()){
            int p1 = scanner.nextInt();
            int p2 = scanner.nextInt();

            int a1 = scanner.nextInt();
            int a2 = scanner.nextInt();
            int a3 = scanner.nextInt();
            int a4 = scanner.nextInt();

            int z1 = scanner.nextInt();

            int e1 = scanner.nextInt();

            int w1 = scanner.nextInt();
            int w2 = scanner.nextInt();

            if(p1 > 0 && p1 <= 9 && p2 > 0 && p2 <= 9){
                System.out.println(0);
            }else{
                System.out.println(-1);
            }
            if(a1 >=0 && a1 < p1 && a3>=0 && a3 < p1 & a2 >=0 && a2 < p2 && a4 >=0 && a4 < p2){
                System.out.println(0);
            }else{
                System.out.println(-1);
            }
            if(z1 >= 0 && z1 < p1 && p1 + 1 <= 9){
                System.out.println(0);
            }else{
                System.out.println(-1);
            }

            if(e1 >=0 && e1 < p2 && p2 + 1 <= 9){
                System.out.println(0);
            }else{
                System.out.println(-1);
            }
            if(w1 >=0 && w1 < p1 && w2>=0 && w2< p2){
                System.out.println(0);
            }else{
                System.out.println(-1);
            }
        }
    }
}
```

## 19.统计大写字母个数

> ## 描述
>
> 找出给定字符串中大写字符(即'A'-'Z')的个数。
>
> ### 输入描述：
>
> 本题含有多组样例输入
> 对于每组样例，输入一行，代表待统计的字符串
>
> ### 输出描述：
>
> 对于每组样例，输出一个整数，代表字符串中大写字母的个数
>
> ## 示例1
>
> 输入：
>
> ```
> add123#$%#%#O
> 150175017(&^%&$vabovbao
> ```
>
> 复制
>
> 输出：
>
> ```
> 1
> 0
> ```

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNextLine()){
            String str = scanner.nextLine();
            int count = 0;
            for(int i=0;i<str.length();i++){
                if(str.charAt(i) >= 'A' && str.charAt(i) <= 'Z'){
                    count++;
                }
            }
            System.out.println(count);
        }
    }
}
```

## 20.最长回文子串

> ## 描述
>
> 给定一个仅包含小写字母的字符串，求它的最长回文子串的长度。
>
> 所谓回文串，指左右对称的字符串。
>
> 所谓子串，指一个字符串删掉其部分前缀和后缀（也可以不删）的字符串
>
> （注意：记得加上while处理多个测试用例）
>
> ### 输入描述：
>
> 输入一个仅包含小写字母的字符串
>
> ### 输出描述：
>
> 返回最长回文子串的长度
>
> ## 示例1
>
> 输入：
>
> ```
> cdabbacc
> ```
>
> 复制
>
> 输出：
>
> ```
> 4
> ```
>
> 复制
>
> 说明：
>
> ```
> abba为最长的回文子串 
> ```

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNextLine()){
            String str = scanner.nextLine();
            int maxCount = 0;
            for(int i=0;i<str.length();i++){
                for(int j=i+1;j<=str.length();j++){
                    String str1 = str.substring(i,j);
                    StringBuffer stringBuffer = new StringBuffer(str1);
                    if(str1.equals(stringBuffer.reverse().toString())){
                        if(str1.length() > maxCount){
                            maxCount = str1.length();
                        }
                    }
                }
            }
            System.out.println(maxCount);
        }
    }
}
```

## 21.求最大连续bit数

> ## 描述
>
> 求一个byte数字对应的二进制数字中1的最大连续数，例如3的二进制为00000011，最大连续2个1
>
> 本题含有多组样例输入。
>
> ### 输入描述：
>
> 输入一个byte数字
>
> ### 输出描述：
>
> 输出转成二进制之后连续1的个数
>
> ## 示例1
>
> 输入：
>
> ```
> 3
> 5
> ```
>
> 复制
>
> 输出：
>
> ```
> 2
> 1
> ```
>
> 复制
>
> 说明：
>
> ```
> 3的二进制表示是11，最多有2个连续的1。
> 5的二进制表示是101，最多只有1个连续的1。 
> ```

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner  scanner = new Scanner(System.in);
        while(scanner.hasNextInt()){
            int b = scanner.nextInt();
            StringBuffer stringBuffer = new StringBuffer();
            while(b >= 2){
                stringBuffer.append(b%2);
                b = b / 2;
            }
            if(b == 1){
                stringBuffer.append("1");
            }else{
                stringBuffer.append("0");
            }
            int maxInt = 0;
            int temp = 0;
            for(int i=0;i<stringBuffer.length();i++){
                if(temp > maxInt){
                    maxInt = temp;
                }
                if(stringBuffer.toString().charAt(i) == '1'){
                    temp++;
                }else{
                    temp = 0;
                }
            }
            if(temp > maxInt){
                maxInt = temp;
            }
            System.out.println(maxInt);
        }
    }
}
```

## 22.密码强度等级

> ## 描述
>
> 密码按如下规则进行计分，并根据不同的得分为密码进行安全等级划分。
>
> 一、密码长度:
>
> 5 分: 小于等于4 个字符
>
> 10 分: 5 到7 字符
>
> 25 分: 大于等于8 个字符
>
> 二、字母:
>
> 0 分: 没有字母
>
> 10 分: 全都是小（大）写字母
>
> 20 分: 大小写混合字母
>
> 三、数字:
>
> 0 分: 没有数字
>
> 10 分: 1 个数字
>
> 20 分: 大于1 个数字
>
> 四、符号:
>
> 0 分: 没有符号
>
> 10 分: 1 个符号
>
> 25 分: 大于1 个符号
>
> 五、奖励:
>
> 2 分: 字母和数字
>
> 3 分: 字母、数字和符号
>
> 5 分: 大小写字母、数字和符号
>
> 最后的评分标准:
>
> \>= 90: 非常安全
>
> \>= 80: 安全（Secure）
>
> \>= 70: 非常强
>
> \>= 60: 强（Strong）
>
> \>= 50: 一般（Average）
>
> \>= 25: 弱（Weak）
>
> \>= 0: 非常弱
>
> 
>
> 对应输出为：
>
> VERY_SECURE
>
> SECURE,
>
> VERY_STRONG,
>
> STRONG,
>
> AVERAGE,
>
> WEAK,
>
> VERY_WEAK,
>
>
> 请根据输入的密码字符串，进行安全评定。
>
> 注：
>
> 字母：a-z, A-Z
>
> 数字：-9
>
> 符号包含如下： (ASCII码表可以在UltraEdit的菜单view->ASCII Table查看)
>
> !"#$%&'()*+,-./   (ASCII码：x21~0x2F)
>
> :;<=>?@       (ASCII<=><=><=><=><=>码：x3A~0x40)
>
> [\]^_`       (ASCII码：x5B~0x60)
>
> {|}~        (ASCII码：x7B~0x7E)
>
> 
>
> ### 输入描述：
>
> 本题含有多组输入样例。
> 每组样例输入一个string的密码
>
> ### 输出描述：
>
> 每组样例输出密码等级
>
> ## 示例1
>
> 输入：
>
> ```
> 38$@NoNoNo
> 123
> ```
>
> 复制
>
> 输出：
>
> ```
> VERY_SECURE
> WEAK
> ```
>
> 复制
>
> 说明：
>
> ```
> 第一组样例密码强度为95分。
> 第二组样例密码强度为25分。
> ```

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNext()){
            String password = scanner.next();
            int score = 0;
            if(password.length() <= 4){
                score += 5;
            }else if(password.length() <= 7){
                score += 10;
            }else{
                score += 25;
            }
            int upcaseCount = 0;
            int lowCaseCount = 0;
            int dightCount = 0;
            int charCount = 0;
            
            for(int i=0;i<password.length();i++){
                if(password.charAt(i) >= '0' && password.charAt(i) <= '9'){
                    dightCount++;
                } else
                if(password.charAt(i) >= 'a' && password.charAt(i) <= 'z'){
                    lowCaseCount++;
                } else
                if(password.charAt(i) >= 'A' && password.charAt(i) <= 'Z'){
                    upcaseCount++;
                } else 
                if((password.charAt(i) >= 33 && password.charAt(i) <= 47) ||
                  (password.charAt(i) >= 58 && password.charAt(i) <= 64) ||
                  (password.charAt(i) >= 91 && password.charAt(i) <= 96) ||
                  (password.charAt(i) >= 123 && password.charAt(i) <= 126)){
                    charCount++;
                }
            }
            
            if(upcaseCount > 0 && lowCaseCount > 0){
                score += 20;
            }else if(upcaseCount > 0 || lowCaseCount > 0){
                score += 10;
            }
            
            if(dightCount == 1){
                 score += 10;
            }else if(dightCount > 1){
                 score += 20;
            }
            
            if(charCount == 1){
                score += 10;
            }else if(charCount > 1){
                score += 25;
            }
            
            if(charCount >= 1 && dightCount>=1 && upcaseCount >= 1 && lowCaseCount >= 1){
                 score += 5;
            }else if(charCount >= 1 && dightCount>=1 && (upcaseCount >= 1 || lowCaseCount >= 1)){
                 score += 3;
            }else if((upcaseCount >= 1 || lowCaseCount >= 1) && dightCount>=1){
                 score += 2;
            }
            if(score >= 90){
                System.out.println("VERY_SECURE");
            }else
            if(score >= 80){
                System.out.println("SECURE");
            }else
            if(score >= 70){
                System.out.println("VERY_STRONG");
            }else
            if(score >= 60){
                System.out.println("STRONG");
            }else
             if(score >= 50){
                System.out.println("AVERAGE");
            }else
             if(score >= 25){
                System.out.println("WEAK");
            }else
            if(score >= 0){
                System.out.println("VERY_WEAK");
            }
        }
    }
}
```

## 23.*走方格的方案数

> ## 描述
>
> 请计算n*m的棋盘格子（n为横向的格子数，m为竖向的格子数）沿着各自边缘线从左上角走到右下角，总共有多少种走法，要求不能走回头路，即：只能往右和往下走，不能往左和往上走。
>
> 本题含有多组样例输入。
>
> ### 输入描述：
>
> 每组样例输入两个正整数n和m，用空格隔开。(1≤n,m≤8)
>
> ### 输出描述：
>
> 每组样例输出一行结果
>
> ## 示例1
>
> 输入：
>
> ```
> 2 2
> 1 2
> ```
>
> 复制
>
> 输出：
>
> ```
> 6
> 3
> ```

```java
import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while(sc.hasNext()){
            int num1= sc.nextInt();
            int num2= sc.nextInt();
            System.out.println(methods(num1,num2));
        }
    }
    public static  int methods(int num1,int num2){
        if(num1 == 0 ||num2 == 0){
            return 1;
        }
        return methods(num1-1,num2)+methods(num1,num2-1);
    }
}
```

## 24.等差数列

> ## 描述
>
> 功能:等差数列 2，5，8，11，14。。。。
>
> 输入:正整数N >0
>
> 输出:求等差数列前N项和
>
> 本题为多组输入，请使用while(cin>>)等形式读取数据
>
> ### 输入描述：
>
> 输入一个正整数。
>
> ### 输出描述：
>
> 输出一个相加后的整数。
>
> ## 示例1
>
> 输入：
>
> ```
> 2
> ```
>
> 复制
>
> 输出：
>
> ```
> 7
> ```

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNextInt()){
            int number = scanner.nextInt();
            int[] nums = new int[number];
            nums[0] = 2;
            int count = 2;
            for(int i=1;i<number;i++){
                nums[i] = nums[i-1] + 3;
                count += nums[i];
            }
            System.out.println(count);
        }
    }
}
```

## 25.字符逆序

> ## 描述
>
> 将一个字符串str的内容颠倒过来，并输出。str的长度不超过100个字符。
>
> ### 输入描述：
>
> 输入一个字符串，可以有空格
>
> ### 输出描述：
>
> 输出逆序的字符串
>
> ## 示例1
>
> 输入：
>
> ```
> I am a student
> ```
>
> 复制
>
> 输出：
>
> ```
> tneduts a ma I
> ```

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNextLine()){
            String str = scanner.nextLine();
            for(int i=str.length()-1;i>=0;i--){
                System.out.print(str.charAt(i));
            }
        }
    }
}
```

## 26.求最小公倍数

> ## 描述
>
> 正整数A和正整数B 的最小公倍数是指 能被A和B整除的最小的正整数值，设计一个算法，求输入A和B的最小公倍数。
>
> ### 输入描述：
>
> 输入两个正整数A和B。
>
> ### 输出描述：
>
> 输出A和B的最小公倍数。
>
> ## 示例1
>
> 输入：
>
> ```
> 5 7
> ```
>
> 复制
>
> 输出：
>
> ```
> 35
> ```

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNextInt()){
            int number1 = scanner.nextInt();
            int number2 = scanner.nextInt();
            for(int i=1;i<=number1*number2;i++){
                if(i%number1 == 0 && i%number2==0){
                    System.out.println(i);
                    break;
                }
            }
        }
    }
}
```

## 27.*求解立方根

> ## 描述
>
> 计算一个数字的立方根，不使用库函数。
>
> 保留一位小数。
>
> ### 输入描述：
>
> 待求解参数，为double类型（一个实数）
>
> ### 输出描述：
>
> 输入参数的立方根。保留一位小数。
>
> ## 示例1
>
> 输入：
>
> ```
> 216
> ```
>
> 复制
>
> 输出：
>
> ```
> 6.0
> ```

```java
 import java.util.*;
    /**
    *  牛顿迭代思想: x = (3*x + y/x/x)/4;
    */
    public class Main{
        public static void main(String[] args){
            Scanner sc = new Scanner(System.in);
            double n = sc.nextDouble();
            double m = get(n);
            System.out.println(String.format("%.1f",m));
        }
        
        public static double get(double n){
            double a, b;
            a = n;
            if(n == 0){
                return 0;
            }
            // 利用迭代法进行求解 -- 牛顿迭代法
            b = (3 * a + n / a / a) / 4;
            // Math.abs(x)返回指定数字x的绝对值
            while(Math.abs(b - a) > 0.000001){
                a = b;
                b = (3 * a + n / a / a) / 4;
            }
            return b;
        }
    }
```

## 28.*Redraiment的走法

> ## 描述
>
> Redraiment是走梅花桩的高手。Redraiment可以选择任意一个起点，从前到后，但只能从低处往高处的桩子走。他希望走的步数最多，你能替Redraiment研究他最多走的步数吗？
>
> 本题含有多组样例输入
>
> ### 输入描述：
>
> 输入多组数据，1组有2行，第1行先输入数组的个数，第2行再输入梅花桩的高度
>
> ### 输出描述：
>
> 一组输出一个结果
>
> ## 示例1
>
> 输入：
>
> ```
> 6
> 2 5 1 5 4 5 
> 3
> 3 2 1
> ```
>
> 复制
>
> 输出：
>
> ```
> 3
> 1
> ```
>
> 复制
>
> 说明：
>
> ```
> 6个点的高度各为 2 5 1 5 4 5
> 如从第1格开始走,最多为3步, 2 4 5
> 从第2格开始走,最多只有1步,5
> 而从第3格开始走最多有3步,1 4 5
> 从第5格开始走最多有2步,4 5
> 所以这个结果是3。   
> ```

```java
import java.util.Scanner;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        while(sc.hasNextInt()){
            int n = sc.nextInt();
            int[] a = new int[n];
            int[] dp = new int[n];
            for(int i = 0; i < n; i++){
                a[i] = sc.nextInt();
            }           
            //dp[i] 保留了从第一个到第i-1个庄子能走的最大步数
            for(int i = 0 ; i < n; i++){
                dp[i] = 1;
                for(int j = 0; j < i; j++){
                    if(a[j] < a[i]){
                        //最终dp[i]的值为其前面的最大的dp[j] + 1；
                        dp[i] = Math.max(dp[i],dp[j] + 1);
                    }
                }
            }
            int max = 1;
            for(int i = 0; i < n; i++){
                if(dp[i] > max){
                    max = dp[i];
                }
            }
            System.out.println(max);
        }
        sc.close();
    }
}
```

## 29.字符统计

> ## 描述
>
> 输入一个只包含小写英文字母和数字的字符串，按照不同字符统计个数由多到少输出统计结果，如果统计的个数相同，则按照ASCII码由小到大排序输出。
> 本题含有多组样例输入
>
> ### 输入描述：
>
> 一个只包含小写英文字母和数字的字符串。
>
> ### 输出描述：
>
> 一个字符串，为不同字母出现次数的降序表示。若出现次数相同，则按ASCII码的升序输出。
>
> ## 示例1
>
> 输入：
>
> ```
> aaddccdc
> 1b1bbbbbbbbb
> ```
>
> 复制
>
> 输出：
>
> ```
> cda
> b1
> ```
>
> 复制
>
> 说明：
>
> ```
> 第一个样例里，c和d出现3次，a出现2次，但c的ASCII码比d小，所以先输出c，再输出d，最后输出a.
> ```

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNextLine()){
            String str = scanner.nextLine();
            Map<Character,Integer> map = new HashMap<Character,Integer>();
            for(int i=0;i<str.length();i++){
                if(map.keySet().contains(str.charAt(i))){
                    map.put(str.charAt(i),map.get(str.charAt(i)) + 1);
                }else{
                    map.put(str.charAt(i), 1);
                }
            }
            List<Map.Entry<Character,Integer>> list = new ArrayList<>(map.entrySet());
            // 1 会交换  -1 是不动
            Collections.sort(list, (o1, o2) -> {
                if(o1.getValue() < o2.getValue()){
                        return 1;
                }else if(o1.getValue() == o2.getValue()){
                    if(o1.getKey().charValue() > o2.getKey().charValue()){
                        return 1;
                    }
                }
                return -1;
            });
            list.forEach(entry->{
                System.out.print(entry.getKey());
            });
            System.out.println();
        }
    }
}
```

## 30.自守数

> ## 描述
>
> 自守数是指一个数的平方的尾数等于该数自身的自然数。例如：25^2 = 625，76^2 = 5776，9376^2 = 87909376。请求出n以内的自守数的个数
>
> 接口说明
> /*
> 功能: 求出n以内的自守数的个数
> 输入参数：
> int n
>
> 返回值：
> n以内自守数的数量。
> */
>
> public static int CalcAutomorphicNumbers( int n)
> {
> /*在这里实现功能*/
>
> return 0;
>
> }
>
> 本题有多组输入数据，请使用while(cin>>)等方式处理
>
> ### 输入描述：
>
> int型整数
>
> ### 输出描述：
>
> n以内自守数的数量。
>
> ## 示例1
>
> 输入：
>
> ```
> 2000
> ```
>
> 复制
>
> 输出：
>
> ```
> 8
> ```

```java
import java.util.*;
import java.lang.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNextInt()){
            int number = scanner.nextInt();
            int count = 0;
            for(int i=0;i<=number;i++){
                if(String.valueOf(i*i).endsWith(String.valueOf(i))){
                    count++;
                }
            }
            System.out.println(count);
        }
    }
}
```

## 31.表示数字

> ## 描述
>
> 将一个字符中所有的整数前后加上符号“*”，其他字符保持不变。连续的数字视为一个整数。
>
> 注意：本题有多组样例输入。
>
> ### 输入描述：
>
> 输入一个字符串
>
> ### 输出描述：
>
> 字符中所有出现的数字前后加上符号“*”，其他字符保持不变
>
> ## 示例1
>
> 输入：
>
> ```
> Jkdi234klowe90a3
> 5151
> ```
>
> 复制
>
> 输出：
>
> ```
> Jkdi*234*klowe*90*a*3*
> *5151*
> ```

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNextLine()){
            String str = scanner.nextLine();
            StringBuffer stringBuffer = new StringBuffer();
            for(int i=0;i<str.length();i++){
                if(i == 0){
                    if(str.charAt(i) >= '0' && str.charAt(i) <= '9'){
                        if(str.charAt(i+1) < '0' || str.charAt(i+1) > '9'){
                            stringBuffer.append("*").append(str.charAt(i)).append("*");
                        }else{
                            stringBuffer.append("*").append(str.charAt(i));
                        }
                    }else {
                        stringBuffer.append(str.charAt(i));
                    }
                }else if(i == str.length()-1){
                    if(str.charAt(i) >= '0' && str.charAt(i) <= '9'){
                        if(str.charAt(i-1) < '0' || str.charAt(i-1) > '9'){
                            stringBuffer.append("*").append(str.charAt(i)).append("*");
                        }else{
                            stringBuffer.append(str.charAt(i)).append("*");
                        }
                    }else{
                        stringBuffer.append(str.charAt(i));
                    }
                } else {
                    if(str.charAt(i) >= '0' && str.charAt(i) <= '9'){
                        if (str.charAt(i - 1) < '0' || str.charAt(i - 1) > '9') {
                            stringBuffer.append("*");
                        }
                        stringBuffer.append(str.charAt(i));
                        if (str.charAt(i + 1) < '0' || str.charAt(i + 1) > '9'){
                            stringBuffer.append("*");
                        }
                    }else{
                        stringBuffer.append(str.charAt(i));
                    }
                }
            }
            System.out.println(stringBuffer.toString());
        }
    }
}
```

## 32.合法IP

> ## 描述
>
> 现在IPV4下用一个32位无符号整数来表示，一般用点分方式来显示，点将IP地址分成4个部分，每个部分为8位，表示成一个无符号整数（因此不需要用正号出现），如10.137.17.1，是我们非常熟悉的IP地址，一个IP地址串中没有空格出现（因为要表示成一个32数字）。
>
> 现在需要你用程序来判断IP是否合法。
>
> 注意本题有多组样例输入。
>
> 
>
> ### 输入描述：
>
> 输入一个ip地址，保证是xx.xx.xx.xx的形式（xx为整数）
>
> ### 输出描述：
>
> 返回判断的结果YES or NO
>
> ## 示例1
>
> 输入：
>
> ```
> 10.138.15.1
> 255.0.0.255
> 255.255.255.1000
> ```
>
> 复制
>
> 输出：
>
> ```
> YES
> YES
> NO
> ```

```java
import java.util.*;
import java.lang.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNextLine()){
            String str = scanner.nextLine();
            String[] nums =  str.split("\\.");
            if(nums.length != 4){
                System.out.println("NO");
                continue;
            }
            boolean f = true;
            for(int i=0;i<nums.length;i++){
                int n = Integer.parseInt(nums[i]);
                if(n < 0 || n > 255){
                    System.out.println("NO");
                    f = false;
                    break;
                }
            }
            if(f){
                System.out.println("YES");
            }
        }
    }
}
```

## 33.查找两个字符串a,b中的最长公共子串

> ## 描述
>
> 查找两个字符串a,b中的最长公共子串。若有多个，输出在较短串中最先出现的那个。
>
> 注：子串的定义：将一个字符串删去前缀和后缀（也可以不删）形成的字符串。请和“子序列”的概念分开！
>
> 本题含有多组输入数据！
>
> ### 输入描述：
>
> 输入两个字符串
>
> ### 输出描述：
>
> 返回重复出现的字符
>
> ## 示例1
>
> 输入：
>
> ```
> abcdefghijklmnop
> abcsafjklmnopqrstuvw
> ```
>
> 复制
>
> 输出：
>
> ```
> jklmnop
> ```

```java
import java.util.*;
import java.lang.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNext()){
            String str1 = scanner.next();
            String str2 = scanner.next();
            if(str1.length() > str2.length()){
                String tempStr = str2;
                str2 = str1;
                str1 = tempStr;
            }
            int maxCount = 0;
            String maxStr = "";
            for(int i=0;i<str1.length();i++){
                for(int j=0;j<i;j++){
                    String str = str1.substring(j,i+1);
                    if(str2.contains(str) && str.length() > maxCount){
                        maxCount = str.length();
                        maxStr = str;
                    }
                }
            }
            System.out.println(maxStr);
        }
    }
}
```

## 34.字符串排序

> ## 描述
>
> 编写一个程序，将输入字符串中的字符按如下规则排序。
>
> 规则 1 ：英文字母从 A 到 Z 排列，不区分大小写。
>
> 如，输入： Type 输出： epTy
>
> 规则 2 ：同一个英文字母的大小写同时存在时，按照输入顺序排列。
>
> 如，输入： BabA 输出： aABb
>
> 规则 3 ：非英文字母的其它字符保持原来的位置。
>
> 如，输入： By?e 输出： Be?y
>
> 注意有多组测试数据，即输入有多行，每一行单独处理（换行符隔开的表示不同行）
>
> ### 输入描述：
>
> 输入字符串
>
> ### 输出描述：
>
> 输出字符串
>
> ## 示例1
>
> 输入：
>
> ```
> A Famous Saying: Much Ado About Nothing (2012/8).
> ```
>
> 复制
>
> 输出：
>
> ```
> A aaAAbc dFgghh: iimM nNn oooos Sttuuuy (2012/8).
> ```

```java
import java.util.*;
public class Main {
    public Main() {
    }
    public String sort(String str) {
        // 先将英文字母收集起来
        List<Character> letters = new ArrayList<>(str.length());
        for (char ch : str.toCharArray()) {
            if (Character.isLetter(ch)) {
                letters.add(ch);
            }
        }
        // 将英文字母先排序好
        letters.sort(new Comparator<Character>() {
            public int compare(Character o1, Character o2) {
                return Character.toLowerCase(o1) - Character.toLowerCase(o2);
            }
        });
        // 若是非英文字母则直接添加
        StringBuilder result = new StringBuilder();
        for (int i = 0, j = 0; i < str.length(); i++) {
            if (Character.isLetter(str.charAt(i))) {
                result.append(letters.get(j++));
            }
            else {
                result.append(str.charAt(i));
            }
        }
        return result.toString();
    }
    public static void main(String[] args) {
        Main solution = new Main();
        Scanner in = new Scanner(System.in);
        while (in.hasNextLine()) {
            String str = in.nextLine();
            String res = solution.sort(str);
            System.out.println(res);
        }
    }
}
```

## 35.截取字符串

> ## 描述
>
> 输入一个字符串和一个整数k，截取字符串的前k个字符并输出
>
> 本题输入含有多组数据
>
> ### 输入描述：
>
> 1.输入待截取的字符串
>
> 2.输入一个正整数k，代表截取的长度
>
> ### 输出描述：
>
> 截取后的字符串
>
> ## 示例1
>
> 输入：
>
> ```
> abABCcDEF
> 6
> ```
>
> 复制
>
> 输出：
>
> ```
> abABCc
> ```
>
> 复制
>
> ## 示例2
>
> 输入：
>
> ```
> ffIKEHauv
> 1
> bdxPKBhih
> 6
> ```
>
> 复制
>
> 输出：
>
> ```
> f
> bdxPKB
> ```

```java
import java.util.*;
import java.lang.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNext()){
            String str = scanner.next();
            int num = scanner.nextInt();
            for(int i=0;i<num;i++){
                System.out.print(str.charAt(i));
            }
            System.out.println();
        }
    }
}
```

## 36.找出字符串中第一个只出现一次的字符

> ## 描述
>
> 找出字符串中第一个只出现一次的字符
>
> ### 输入描述：
>
> 输入几个非空字符串
>
> ### 输出描述：
>
> 输出第一个只出现一次的字符，如果不存在输出-1
>
> ## 示例1
>
> 输入：
>
> ```
> asdfasdfo
> aabb
> ```
>
> 复制
>
> 输出：
>
> ```
> o
> -1
> ```

```java
import java.util.*;
import java.lang.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNext()){
            String str = scanner.next();
            StringBuffer stringBuffer = new StringBuffer();
            String deleteStr = "";
            for(int i=0;i<str.length();i++){
                if(stringBuffer.toString().contains(String.valueOf(str.charAt(i)))){
                    String tempStr = stringBuffer.toString();
                    stringBuffer.delete(0,stringBuffer.length());
 stringBuffer.append(tempStr.replaceAll(String.valueOf(str.charAt(i)),""));
                    deleteStr += String.valueOf(str.charAt(i));
                }else{
                    if(!deleteStr.contains(String.valueOf(str.charAt(i)))){
                        stringBuffer.append(str.charAt(i));
                    }
                }
            }
            if(stringBuffer.toString().length() < 1){
                System.out.println("-1");
            }else{
                System.out.println(stringBuffer.charAt(0));
            }
        }
    }
}
```

## 37.统计字符

> ## 描述
>
> 输入一行字符，分别统计出包含英文字母、空格、数字和其它字符的个数。
>
> 本题包含多组输入。
>
> ### 输入描述：
>
> 输入一行字符串，可以有空格
>
> ### 输出描述：
>
> 统计其中英文字符，空格字符，数字字符，其他字符的个数
>
> ## 示例1
>
> 输入：
>
> ```
> 1qazxsw23 edcvfr45tgbn hy67uj m,ki89ol.\\/;p0-=\\][
> ```
>
> 复制
>
> 输出：
>
> ```
> 26
> 3
> 10
> 12
> ```

```java
import java.util.*;
import java.lang.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNextLine()){
            String str = scanner.nextLine();
            int letterCount = 0;
            int spaceCount = 0;
            int dightCount = 0;
            int otherCount = 0;
            for(int i=0;i<str.length();i++){
                if(Character.isLetter(str.charAt(i))){
                    letterCount++;
                } else if(Character.isDigit(str.charAt(i))){
                    dightCount++;
                } else if(Character.isSpace(str.charAt(i))){
                    spaceCount++;
                }else{
                    otherCount++;
                }
            }
            System.out.println(letterCount);
            System.out.println(spaceCount);
            System.out.println(dightCount);
            System.out.println(otherCount);
        }
    }
}
```

## 38.图片整理

> ## 描述
>
> Lily上课时使用字母数字图片教小朋友们学习英语单词，每次都需要把这些图片按照大小（ASCII码值从小到大）排列收好。请大家给Lily帮忙，通过C语言解决。
>
> 本题含有多组样例输入。
>
> ### 输入描述：
>
> Lily使用的图片包括"A"到"Z"、"a"到"z"、"0"到"9"。输入字母或数字个数不超过1024。
>
> ### 输出描述：
>
> Lily的所有图片按照从小到大的顺序输出
>
> ## 示例1
>
> 输入：
>
> ```
> Ihave1nose2hands10fingers
> ```
>
> 复制
>
> 输出：
>
> ```
> 0112Iaadeeefghhinnnorsssv
> ```

```java
import java.util.*;
import java.lang.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNext()){
            String str = scanner.next();
            char[] chars = str.toCharArray();
            for(int i=0;i<chars.length;i++){
                for(int j=i+1;j<chars.length;j++){
                    if(chars[i] > chars[j]){
                        char temp = chars[j];
                        chars[j] = chars[i];
                        chars[i] = temp;
                    }
                }
            }
            for(int i=0;i<chars.length;i++){
                System.out.print(chars[i]);
            }
             System.out.println();
        }
    }
}
```

## 39.DNA序列

> ## 描述
>
> 一个DNA序列由A/C/G/T四个字母的排列组合组成。G和C的比例（定义为GC-Ratio）是序列中G和C两个字母的总的出现次数除以总的字母数目（也就是序列长度）。在基因工程中，这个比例非常重要。因为高的GC-Ratio可能是基因的起始点。
>
> 给定一个很长的DNA序列，以及限定的子串长度N，请帮助研究人员在给出的DNA序列中从左往右找出GC-Ratio最高且长度为N的第一个子串。
>
> DNA序列为ACGT的子串有:ACG,CG,CGT等等，但是没有AGT，CT等等
>
> ### 输入描述：
>
> 输入一个string型基因序列，和int型子串的长度
>
> ### 输出描述：
>
> 找出GC比例最高的子串,如果有多个则输出第一个的子串
>
> ## 示例1
>
> 输入：
>
> ```
> ACGT
> 2
> ```
>
> 复制
>
> 输出：
>
> ```
> CG
> ```
>
> 复制
>
> 说明：
>
> ```
> ACGT长度为2的子串有AC,CG,GT3个，其中AC和GT2个的GC-Ratio都为0.5，CG为1，故输出CG  
> ```

```
package cn.com.css.huawei;
import java.util.*;
import java.lang.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNext()){
            String str = scanner.next();
            int num = scanner.nextInt();
            if(num >= str.length()){
                System.out.println(str);
                continue;
            }
            List<String> strings = new ArrayList<>();
            for(int i=0;i<str.length()-num;i++){
                String s = str.substring(i,i+num);
                strings.add(0,s);
            }
            strings.sort((o1,o2)->{
                if(getPercent(o1) - getPercent(o2) < 0){
                    return 1;
                }
                return -1;
            });
            if(strings.size() > 0){
                System.out.println(strings.get(0));
            }

        }
    }

    public static float getPercent(String str){
        int c = 0;
        for(int i=0;i<str.length();i++){
            if(str.charAt(i) == 'G' || str.charAt(i) == 'C'){
                c++;
            }
        }
        return (float) c/(float) str.length();
    }
}
```

## 40.简单密码

> ## 描述
>
> 密码是我们生活中非常重要的东东，我们的那么一点不能说的秘密就全靠它了。哇哈哈. 接下来渊子要在密码之上再加一套密码，虽然简单但也安全。
>
> 假设渊子原来一个BBS上的密码为zvbo9441987,为了方便记忆，他通过一种算法把这个密码变换成YUANzhi1987，这个密码是他的名字和出生年份，怎么忘都忘不了，而且可以明目张胆地放在显眼的地方而不被别人知道真正的密码。
>
> 他是这么变换的，大家都知道手机上的字母： 1--1， abc--2, def--3, ghi--4, jkl--5, mno--6, pqrs--7, tuv--8 wxyz--9, 0--0,就这么简单，渊子把密码中出现的小写字母都变成对应的数字，数字和其他的符号都不做变换，
>
> 声明：密码中没有空格，而密码中出现的大写字母则变成小写之后往后移一位，如：X，先变成小写，再往后移一位，不就是y了嘛，简单吧。记住，z往后移是a哦。
>
> ### 输入描述：
>
> 输入包括多个测试数据。输入是一个明文，密码长度不超过100个字符，输入直到文件结尾
>
> ### 输出描述：
>
> 输出渊子真正的密文
>
> ## 示例1
>
> 输入：
>
> ```
> YUANzhi1987
> ```
>
> 复制
>
> 输出：
>
> ```
> zvbo9441987
> ```

```java
import java.util.*;
import java.lang.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNext()){
            String str1 = scanner.next();
            for(int i =0 ;i<str1.length();i++){
                if(Character.isUpperCase(str1.charAt(i))){
                    System.out.print((char)(Character.toLowerCase(str1.charAt(i)) + 1) == '{'?'a':(char)(Character.toLowerCase(str1.charAt(i)) + 1)); 
                }else if(Character.isLowerCase(str1.charAt(i))){
                    switch(str1.charAt(i)){
                        case 'a':
                        case 'b':
                        case 'c':
                            System.out.print("2"); 
                            break;
                        case 'd':
                        case 'e':
                        case 'f':
                            System.out.print("3");
                            break;
                        case 'g':
                        case 'h':
                        case 'i':
                            System.out.print("4");
                            break;
                        case 'j':
                        case 'k':
                        case 'l':
                            System.out.print("5");
                            break;
                        case 'm':
                        case 'n':
                        case 'o':
                            System.out.print("6");
                            break;
                        case 'p':
                        case 'q':
                        case 'r':
                        case 's':
                            System.out.print("7");
                            break;
                        case 't':
                        case 'u':
                        case 'v':
                            System.out.print("8");
                            break;
                        case 'w':
                        case 'x':
                        case 'y':
                        case 'z':
                            System.out.print("9");
                            break;
                    }
                }else{
                    System.out.print(str1.charAt(i)); 
                }
            }
            System.out.println(); 
        }
    }
}
```

## 41.字符串加密

> ## 描述
>
> 有一种技巧可以对数据进行加密，它使用一个单词作为它的密匙。下面是它的工作原理：首先，选择一个单词作为密匙，如TRAILBLAZERS。如果单词中包含有重复的字母，只保留第1个，其余几个丢弃。现在，修改过的那个单词属于字母表的下面，如下所示：
>
> A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
>
> T R A I L B Z E S C D F G H J K M N O P Q U V W X Y
>
> 上面其他用字母表中剩余的字母填充完整。在对信息进行加密时，信息中的每个字母被固定于顶上那行，并用下面那行的对应字母一一取代原文的字母(字母字符的大小写状态应该保留)。因此，使用这个密匙，Attack AT DAWN(黎明时攻击)就会被加密为Tpptad TP ITVH。
>
> 请实现下述接口，通过指定的密匙和明文得到密文。
>
> 
>
> 本题有多组输入数据。
>
> 
>
> ### 输入描述：
>
> 先输入key和要加密的字符串
>
> ### 输出描述：
>
> 返回加密后的字符串
>
> ## 示例1
>
> 输入：
>
> ```
> nihao
> ni
> ```
>
> 复制
>
> 输出：
>
> ```
> le
> ```

```java
import java.util.*;
import java.lang.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNext()){
            String str1 = scanner.next();
            String str2 = scanner.next();
            char[] az = new char[26];
            char[] key = new char[26];
            int index = 0;
            String tempStr = "";
            for(int i=0;i<str1.length();i++){
                if(!tempStr.contains(String.valueOf(str1.charAt(i)))){
                    key[index] = str1.charAt(i);
                    index++;
                    tempStr += String.valueOf(str1.charAt(i));
                }
            }
            for(int i= 0; i<26; i++){
                az[i] = (char)(97+i);
                if(!str1.contains(String.valueOf(az[i]))){
                    key[index] = az[i];
                    index++;
                }
            }

            for(int i=0;i<str2.length();i++){
                for(int j=0;j<az.length;j++){
                    if(str2.charAt(i) == az[j]){
                        System.out.print(key[j]);
                    }
                }
            }
            System.out.println();
        }
    }
}
```

## 42.名字的漂亮度

> ## 描述
>
> 给出一个名字，该名字有26个字符组成，定义这个字符串的“漂亮度”是其所有字母“漂亮度”的总和。
> 每个字母都有一个“漂亮度”，范围在1到26之间。没有任何两个不同字母拥有相同的“漂亮度”。字母忽略大小写。
>
> 给出多个名字，计算每个名字最大可能的“漂亮度”。
>
> 本题含有多组数据。
>
> 
>
> ### 输入描述：
>
> 整数N，后续N个名字
>
> ### 输出描述：
>
> 每个名称可能的最大漂亮程度
>
> ## 示例1
>
> 输入：
>
> ```
> 2
> zhangsan
> lisi
> ```
>
> 复制
>
> 输出：
>
> ```
> 192
> 101
> ```

```java
import java.util.*;
import java.lang.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNextInt()){
            int number = scanner.nextInt();
            for(int i=0;i<number;i++){
                String str =  scanner.next();
                Map<Character,Integer> map = new HashMap<>();
                for(int j=0;j<str.length();j++){
                    if(map.keySet().contains(str.charAt(j))){
                        map.put(Character.valueOf(str.charAt(j)),map.get(Character.valueOf(str.charAt(j))) + 1);
                    }else{
                        map.put(Character.valueOf(str.charAt(j)),1);
                    }
                }
                List<Character> list = new ArrayList();
                Set<Character> set = map.keySet();
                list.addAll(set);
                list.sort((o1,o2)-> map.get(o2) - map.get(o1));
                int scoreCount = 0;
                for(int j=0;j<list.size();j++){
                    int score = (26-j) * map.get(list.get(j));
                    scoreCount += score;
                }
                System.out.println(scoreCount);
            }

        }
    }
}
```

## 43.挑7

> ## 描述
>
> 输出7有关数字的个数，包括7的倍数，还有包含7的数字（如17，27，37...70，71，72，73...）的个数（一组测试用例里可能有多组数据，请注意处理）
>
> ### 输入描述：
>
> 一个正整数N。(N不大于30000)
>
> ### 输出描述：
>
> 不大于N的与7有关的数字个数，例如输入20，与7有关的数字包括7,14,17.
>
> ## 示例1
>
> 输入：
>
> ```
> 20
> 10
> ```
>
> 复制
>
> 输出：
>
> ```
> 3
> 1
> ```

```java
import java.util.*;
import java.lang.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNextInt()){
            int number = scanner.nextInt();
            int count = 0;
            for(int i=0;i<=number;i++){
                if(String.valueOf(i).contains("7")){
                    count++;
                }
            }
            for(int i=1;i<number;i++){
                if(i*7 <= number && !String.valueOf(i*7).contains("7")){
                    count++;
                }
            }
            System.out.println(count);
        }
    }
}
```

## 44.查找组成一个偶数最接近的两个素数

> ## 描述
>
> 任意一个偶数（大于2）都可以由2个素数组成，组成偶数的2个素数有很多种情况，本题目要求输出组成指定偶数的两个素数差值最小的素数对。
>
> 本题含有多组样例输入。
>
> ### 输入描述：
>
> 输入一个偶数
>
> ### 输出描述：
>
> 输出两个素数
>
> ## 示例1
>
> 输入：
>
> ```
> 20
> ```
>
> 复制
>
> 输出：
>
> ```
> 7
> 13
> ```

```java
import java.util.*;
import java.lang.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNextInt()){
            int number = scanner.nextInt();
            int value = Integer.MAX_VALUE;
            int[] result = new int[2];
            for(int i=1;i<number;i++){
                int number1 = i;
                int number2 = number - i;
                if(isPrime(number1,number2)){
                    if(number2 > number1 && number2 - number1 < value){
                        value = number2 - number1;
                        result[0] = number1;
                        result[1] = number2;
                    }
                    if((number2 <= number1 && number1 - number2 < value)){
                        value = number1 - number2;
                        result[0] = number2;
                        result[1] = number1;
                    }
                }
            }
            System.out.println(result[0]);
            System.out.println(result[1]);
        }
    }

    public static boolean isPrime(int num1, int num2){
        for(int i = 2;i<num1;i++){
            if(num1%i == 0){
                return false;
            }
        }
        for(int i = 2;i<num2;i++){
            if(num2%i == 0){
                return false;
            }
        }
        return true;
    }
}
```

## 45.高精度整数加法

> ## 描述
>
> 输入两个用字符串表示的整数，求它们所表示的数之和。
>
> 字符串的长度不超过10000。
>
> 本题含有多组样例输入。
>
> ### 输入描述：
>
> 输入两个字符串。保证字符串只含有'0'~'9'字符
>
> ### 输出描述：
>
> 输出求和后的结果
>
> ## 示例1
>
> 输入：
>
> ```
> 9876543210
> 1234567890
> ```
>
> 复制
>
> 输出：
>
> ```
> 11111111100
> ```

```java
import java.util.*;
import java.lang.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNext()){
            String str1 = scanner.next();
            String str2 = scanner.next();
            if(str1.length() < str2.length()){
                String temp = str1;
                str1 = str2;
                str2 = temp;
            }
            str1 = new StringBuffer(str1).reverse().toString();
            str2 = new StringBuffer(str2).reverse().toString();
            StringBuffer stringBuffer = new StringBuffer();
            int add = 0;
            for(int i=0;i<str1.length();i++){
                if(i >= str2.length()){
                    int result = Integer.parseInt(String.valueOf(str1.charAt(i))) + add;
                    if(result >= 10){
                        result = result - 10;
                        stringBuffer.append(result);
                        add = 1;
                    }else{
                        add = 0;
                        stringBuffer.append(result);
                    }
                }else{
                    int n1 = Integer.parseInt(String.valueOf(str1.charAt(i)));
                    int n2 = Integer.parseInt(String.valueOf(str2.charAt(i)));
                    int count = n1 + n2 + add;
                    if(count <= 9){
                        stringBuffer.append(count);
                        add = 0;
                    }else{
                        count = count - 10;
                        stringBuffer.append(count);
                        add = 1;
                    }
                }

            }
            if(add != 0){
                stringBuffer.append(add);
                add = 0;
            }
            System.out.println(stringBuffer.reverse().toString());
        }
    }
}
```

## 46.简单错误记录

> ## 描述
>
> 开发一个简单错误记录功能小模块，能够记录出错的代码所在的文件名称和行号。
>
> 处理：
>
> 1、 记录最多8条错误记录，循环记录，最后只用输出最后出现的八条错误记录。对相同的错误记录只记录一条，但是**错误计数增加。最后一个斜杠后面的带后缀名的部分（保留最后16位）和行号完全匹配的记录才做算是”相同“的错误记录。**
>
> 2、 超过16个字符的文件名称，只记录文件的最后有效16个字符；
>
> 3、 输入的文件可能带路径，记录文件名称不能带路径。
>
> 4、循环记录时，只以第一次出现的顺序为准，后面重复的不会更新它的出现时间，仍以第一次为准
>
> ### 输入描述：
>
> 每组只包含一个测试用例。一个测试用例包含一行或多行字符串。每行包括带路径文件名称，行号，以空格隔开。
>
> ### 输出描述：
>
> 将所有的记录统计并将结果输出，格式：文件名 代码行数 数目，一个空格隔开，如：
>
> ## 示例1
>
> 输入：
>
> ```
> D:\zwtymj\xccb\ljj\cqzlyaszjvlsjmkwoqijggmybr 645
> E:\je\rzuwnjvnuz 633
> C:\km\tgjwpb\gy\atl 637
> F:\weioj\hadd\connsh\rwyfvzsopsuiqjnr 647
> E:\ns\mfwj\wqkoki\eez 648
> D:\cfmwafhhgeyawnool 649
> E:\czt\opwip\osnll\c 637
> G:\nt\f 633
> F:\fop\ywzqaop 631
> F:\yay\jc\ywzqaop 631
> ```
>
> 复制
>
> 输出：
>
> ```
> rzuwnjvnuz 633 1
> atl 637 1
> rwyfvzsopsuiqjnr 647 1
> eez 648 1
> fmwafhhgeyawnool 649 1
> c 637 1
> f 633 1
> ywzqaop 631 2
> ```

```java
import java.util.*;
import java.lang.*;
public class Main{
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        List<ErrorLog> strList = new ArrayList<>();
        while(scanner.hasNextLine()){
            ErrorLog e = new ErrorLog();
            String str = scanner.nextLine();
            if("".equals(str) || str == null){
                break;
            }
            String[] temp = str.split(" ")[0].split("\\\\");
            e.str = temp[temp.length-1];
            e.line = Integer.parseInt(str.split(" ")[1]);
            e.count = 1;
            boolean f = true;
            for(int i=0;i<strList.size();i++){
                if(strList.get(i).equals(e)){
                    ErrorLog el = strList.get(i);
                    el.count++;
                    strList.remove(i);
                    strList.add(i,el);
                    f = false;
                }
            }
            if(f){
                strList.add(e);
            }
        }

        if(strList.size() > 8){
            for (int i = strList.size() - 8; i < strList.size(); i++) {
                if (strList.get(i).str.length() > 16) {
                    System.out.print(strList.get(i).str.substring(strList.get(i).str.length() - 16) + " " + strList.get(i).line + " " + strList.get(i).count);
                    System.out.println();
                } else {
                    System.out.print(strList.get(i).str + " " + strList.get(i).line + " " + strList.get(i).count);
                    System.out.println();
                }
            }
        }else {
            for (int i = 0; i < strList.size(); i++) {
                if (strList.get(i).str.length() > 16) {
                    System.out.print(strList.get(i).str.substring(strList.get(i).str.length() - 16) + " " + strList.get(i).line + " " + strList.get(i).count);
                    System.out.println();
                } else {
                    System.out.print(strList.get(i).str + " " + strList.get(i).line + " " + strList.get(i).count);
                    System.out.println();
                }
            }
        }
    }
}

class ErrorLog{
    public String str;
    public int line;
    public int count;

    @Override
    public boolean equals(Object obj) {
        ErrorLog e = (ErrorLog) obj;
        String[] str1 = e.str.split("\\\\");
        String[] str2 = this.str.split("\\\\");
        return str1[str1.length-1].equals(str2[str2.length-1]) &&  this.line == e.line;
    }
}
```

## 47.字符串加解密

> ## 描述
>
> 1、对输入的字符串进行加解密，并输出。
>
> 2、加密方法为：
>
> 当内容是英文字母时则用该英文字母的后一个字母替换，同时字母变换大小写,如字母a时则替换为B；字母Z时则替换为a；
>
> 当内容是数字时则把该数字加1，如0替换1，1替换2，9替换0；
>
> 其他字符不做变化。
>
> 3、解密方法为加密的逆过程。
>
> 本题含有多组样例输入。
>
> ### 输入描述：
>
> 输入说明
> 输入一串要加密的密码
> 输入一串加过密的密码
>
> ### 输出描述：
>
> 输出说明
> 输出加密后的字符
> 输出解密后的字符
>
> ## 示例1
>
> 输入：
>
> ```
> abcdefg
> BCDEFGH
> ```
>
> 复制
>
> 输出：
>
> ```
> BCDEFGH
> abcdefg
> ```

```java
import java.util.*;
import java.lang.*;
public class Main{
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNext()){
            //str1 待加密字符串，字母大小写转换后变成后一个字母，数字加一
            //str2 待解密字符串，字母大小写转换后变成前一个字母，数字减一
            String str1 = scanner.next();
            String str2 = scanner.next();
            StringBuffer stringBuffer1 = new StringBuffer();
            StringBuffer stringBuffer2 = new StringBuffer();
            for(int i = 0;i<str1.length();i++){
                char ch = str1.charAt(i);
                if(Character.isLetter(ch)){
                    ch = Character.isLowerCase(ch)?Character.toUpperCase(ch):Character.toLowerCase(ch);
                    if(ch == 'z'){
                        stringBuffer1.append("a");
                    }else if(ch == 'Z'){
                        stringBuffer1.append("A");
                    }else{
                        stringBuffer1.append((char)((int)ch + 1));
                    }
                }else if(Character.isDigit(ch)){
                    if(ch == '9'){
                        stringBuffer1.append("0");
                    }else{
                        stringBuffer1.append((char)((int)ch + 1));
                    }
                }else{
                    stringBuffer1.append(ch);
                }

            }
            System.out.println(stringBuffer1.toString());
            for(int i = 0;i<str2.length();i++){
                char ch = str2.charAt(i);
                if(Character.isLetter(ch)){
                    ch = Character.isLowerCase(ch)?Character.toUpperCase(ch):Character.toLowerCase(ch);
                    if(ch == 'a'){
                        stringBuffer2.append("z");
                    }else if(ch == 'A'){
                        stringBuffer2.append("Z");
                    }else{
                        stringBuffer2.append((char)((int)ch - 1));
                    }
                }else if(Character.isDigit(ch)){
                    if(ch == '0'){
                        stringBuffer2.append("9");
                    }else{
                        stringBuffer2.append((char)((int)ch - 1));
                    }
                }else{
                    stringBuffer2.append(ch);
                }

            }
            System.out.println(stringBuffer2);
        }
    }
}

```

## 48.*字符串合并处理

> ## 描述
>
> 按照指定规则对输入的字符串进行处理。
>
> 详细描述：
>
> 将输入的两个字符串合并。
>
> 对合并后的字符串进行排序，要求为：下标为奇数的字符和下标为偶数的字符分别从小到大排序。这里的下标意思是字符在字符串中的位置。
>
> 对排序后的字符串进行操作，如果字符为‘0’——‘9’或者‘A’——‘F’或者‘a’——‘f’，则对他们所代表的16进制的数进行BIT倒序的操作，并转换为相应的大写字符。如字符为‘4’，为0100b，则翻转后为0010b，也就是2。转换后的字符为‘2’； 如字符为‘7’，为0111b，则翻转后为1110b，也就是e。转换后的字符为大写‘E’。
>
> 举例：输入str1为"dec"，str2为"fab"，合并为“decfab”，分别对“dca”和“efb”进行排序，排序后为“abcedf”，转换后为“5D37BF”
>
> 注意本题含有多组样例输入
>
> ### 输入描述：
>
> 本题含有多组样例输入。每组样例输入两个字符串，用空格隔开。
>
> ### 输出描述：
>
> 输出转化后的结果。每组样例输出一行。
>
> ## 示例1
>
> 输入：
>
> ```
> dec fab
> ```
>
> 复制
>
> 输出：
>
> ```
> 5D37BF
> ```

```java
import java.util.*;
 
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        while (in.hasNext()) {
            char[] str1 = in.next().toCharArray();
            char[] str2 = in.next().toCharArray();
            //合并
            StringBuilder res = new StringBuilder();
            res.append(str1);
            res.append(str2);
            //奇偶分类
            StringBuilder even = new StringBuilder();
            StringBuilder odd = new StringBuilder();
            for(int i = 0; i < res.length(); i++){
                if(i%2 == 0) even.append(res.charAt(i));
                else odd.append(res.charAt(i));
            }
            char[] evenC = even.toString().toCharArray();
            char[] oddC = odd.toString().toCharArray();
            Arrays.sort(evenC);
            Arrays.sort(oddC);
            //再次合并,并非直接拼接，而是按原先的奇偶插回
            int oddIndex = 0;
            int evenIndex = 0;
            StringBuilder sorted = new StringBuilder();
            for(int j = 0; j < res.length(); j++){
                if(j%2 == 0){
                    sorted.append(evenC[evenIndex]);
                    evenIndex++;
                }
                else{
                    sorted.append(oddC[oddIndex]);
                    oddIndex++;
                }
            }
 
            //转换
            String dict = "0123456789abcdefABCDEF";//只是为了写起来方便
            char[] sortedChar = sorted.toString().toCharArray();
            for(int m = 0; m < sortedChar.length; m++){
                //如果是0-9,a-f,A-F
                if(dict.contains(String.valueOf(sortedChar[m]))){
                    //转换为十进制
                    int decimal = Integer.parseInt(String.valueOf(sortedChar[m]),16);
                    //转换为二进制,加leading zeros
                    String binary = Integer.toString(decimal,2);
                    binary = String.format("%04d", Integer.valueOf(binary));
                    //翻转
                    String reverseBinary = new StringBuilder(binary).reverse().toString();
                    //转换回16进制，如果是小写字符，变大写
                    //实际上这里无需判断是否是别的字符，因为四位二进制最大也就是1111，对应f,所以直接转换成大写
                    decimal = Integer.parseInt(reverseBinary,2);
                    String hex = Integer.toString(decimal,16).toUpperCase();
                    sortedChar[m] = hex.charAt(0);
                }
            }
            System.out.println(sortedChar);
        }
    }
}
```

## 49.*HJ32 密码截取

> ## 描述
>
> Catcher是MCA国的情报员，他工作时发现敌国会用一些对称的密码进行通信，比如像这些ABBA，ABA，A，123321，但是他们有时会在开始或结束时加入一些无关的字符以防止别国破解。比如进行下列变化 ABBA->12ABBA,ABA->ABAKK,123321->51233214　。因为截获的串太长了，而且存在多种可能的情况（abaaab可看作是aba,或baaab的加密形式），Cathcer的工作量实在是太大了，他只能向电脑高手求助，你能帮Catcher找出最长的有效密码串吗？
>
> 本题含有多组样例输入。
>
> ### 输入描述：
>
> 输入一个字符串
>
> ### 输出描述：
>
> 返回有效密码串的最大长度
>
> ## 示例1
>
> 输入：
>
> ```
> ABBA
> ```
>
> 复制
>
> 输出：
>
> ```
> 4
> ```

```java
import java.util.Scanner;
public class Test {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while(sc.hasNext()){
            String ymm = sc.nextLine();
            StringBuilder qtsString = new StringBuilder();
            for(int i=0;i<ymm.length();i++){
                if(String.valueOf(ymm.charAt(i)).matches("[0-9A-Za-z]")){
                    qtsString.append(ymm.charAt(i));
                }
            }
            int max = 0;
            for(int i = 0;i<qtsString.length();i++){

                max = Math.max(max, longestPalindrome(qtsString.toString(), i, i));

                max = Math.max(max, longestPalindrome(qtsString.toString(), i, i+1));
            }
            System.out.println(max);
        }
    }
    //最长回文数
    public static int longestPalindrome(String s, int left, int right){
        int len = 0;
        while(left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)){
            len = right - left + 1;
            left--;
            right++;
        }
        return len;
    }
}
```

## 50.*HJ16购物单

> ## 描述
>
> 王强今天很开心，公司发给N元的年终奖。王强决定把年终奖用于购物，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：
>
> 
>
> | 主件   | 附件           |
> | ------ | -------------- |
> | 电脑   | 打印机，扫描仪 |
> | 书柜   | 图书           |
> | 书桌   | 台灯，文具     |
> | 工作椅 | 无             |
>
> 
>
> 如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 0 个、 1 个或 2 个附件。附件不再有从属于自己的附件。王强想买的东西很多，为了不超出预算，他把每件物品规定了一个重要度，分为 5 等：用整数 1 **~** 5 表示，第 5 等最重要。他还从因特网上查到了每件物品的价格（都是 10 元的整数倍）。他希望在不超过 N 元（可以等于 N 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。
>
>   设第 j 件物品的价格为 v[j] ，重要度为 w[j] ，共选中了 k 件物品，编号依次为 j 1 ， j 2 ，……， j k ，则所求的总和为：
>
> v[j 1 ]*w[j 1 ]+v[j 2 ]*w[j 2 ]+ … +v[j k ]*w[j k ] 。（其中 * 为乘号）
>
>   请你帮助王强设计一个满足要求的购物单。
>
>  
>
> 
>
> ### 输入描述：
>
> 输入的第 1 行，为两个正整数，用一个空格隔开：N m
>
> （其中 N （ <32000 ）表示总钱数， m （ <60 ）为希望购买物品的个数。）
>
> 
>
> 从第 2 行到第 m+1 行，第 j 行给出了编号为 j-1 的物品的基本数据，每行有 3 个非负整数 v p q
>
> 
>
> （其中 v 表示该物品的价格（ v<10000 ）， p 表示该物品的重要度（ 1 **~** 5 ）， q 表示该物品是主件还是附件。如果 q=0 ，表示该物品为主件，如果 q>0 ，表示该物品为附件， q 是所属主件的编号）
>
>  
>
> 
>
> ### 输出描述：
>
>  输出文件只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（ <200000 ）。
>
> ## 示例1
>
> 输入：
>
> ```
> 1000 5
> 800 2 0
> 400 5 1
> 300 5 1
> 400 3 0
> 500 2 0
> ```
>
> 复制
>
> 输出：
>
> ```
> 2200
> ```

```java
import java.util.Scanner;
 
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int money = sc.nextInt();
        int n = sc.nextInt();
        if(n<=0||money<=0) System.out.println(0);
 
        good[] Gs = new good[n+1];
        for (int i = 1; i <= n; i++) {
            int v = sc.nextInt();
            int p = sc.nextInt();
            int q = sc.nextInt();
            Gs[i] = new good(v,p,q);
 
            if(q>0){
                if(Gs[q].a1==0){
                    Gs[q].setA1(i);
                }else {
                    Gs[q].setA2(i);
                }
            }
        }
 
        int[][] dp = new int[n+1][money+1];
        for (int i = 1; i <= n; i++) {
            int v=0,v1=0,v2=0,v3=0,tempdp=0,tempdp1=0,tempdp2=0,tempdp3=0;
 
            v = Gs[i].v;
 
            tempdp = Gs[i].p*v; //只有主件
 
            if(Gs[i].a1!=0){//主件加附件1
                v1 = Gs[Gs[i].a1].v+v;
                tempdp1 = tempdp + Gs[Gs[i].a1].v*Gs[Gs[i].a1].p;
            }
 
            if(Gs[i].a2!=0){//主件加附件2
                v2 = Gs[Gs[i].a2].v+v;
                tempdp2 = tempdp + Gs[Gs[i].a2].v*Gs[Gs[i].a2].p;
            }
 
            if(Gs[i].a1!=0&&Gs[i].a2!=0){//主件加附件1和附件2
                v3 = Gs[Gs[i].a1].v+Gs[Gs[i].a2].v+v;
                tempdp3 = tempdp + Gs[Gs[i].a1].v*Gs[Gs[i].a1].p + Gs[Gs[i].a2].v*Gs[Gs[i].a2].p;
            }
 
            for(int j=1; j<=money; j++){
                if(Gs[i].q > 0) {   //当物品i是附件时,相当于跳过
                    dp[i][j] = dp[i-1][j];
                } else {
                    dp[i][j] = dp[i-1][j];
                    if(j>=v&&v!=0) dp[i][j] = Math.max(dp[i][j],dp[i-1][j-v]+tempdp);
                    if(j>=v1&&v1!=0) dp[i][j] = Math.max(dp[i][j],dp[i-1][j-v1]+tempdp1);
                    if(j>=v2&&v2!=0) dp[i][j] = Math.max(dp[i][j],dp[i-1][j-v2]+tempdp2);
                    if(j>=v3&&v3!=0) dp[i][j] = Math.max(dp[i][j],dp[i-1][j-v3]+tempdp3);
                }
            }
        }
        System.out.println(dp[n][money]);
 
 
    }
 
 
    /**
     * 定义物品类
     */
    private static class good{
        public int v;  //物品的价格
        public int p;  //物品的重要度
        public int q;  //物品的主附件ID
 
        public int a1=0;   //附件1ID
        public int a2=0;   //附件2ID
 
        public good(int v, int p, int q) {
            this.v = v;
            this.p = p;
            this.q = q;
        }
 
        public void setA1(int a1) {
            this.a1 = a1;
        }
 
        public void setA2(int a2) {
            this.a2 = a2;
        }
    }
}
```

## 51.*HJ35 蛇形矩阵

> ## 描述
>
> 蛇形矩阵是由1开始的自然数依次排列成的一个矩阵上三角形。
>
> 例如，当输入5时，应该输出的三角形为：
>
> 1 3 6 10 15
>
> 2 5 9 14
>
> 4 8 13
>
> 7 12
>
> 11
>
> 请注意本题含有多组样例输入。
>
> ### 输入描述：
>
> 输入正整数N（N不大于100）
>
> ### 输出描述：
>
> 输出一个N行的蛇形矩阵。
>
> ## 示例1
>
> 输入：
>
> ```
> 4
> ```
>
> 复制
>
> 输出：
>
> ```
> 1 3 6 10
> 2 5 9
> 4 8
> 7
> ```

## 52.HJ58 输入n个整数，输出其中最小的k个

> ## 描述
>
> 输入n个整数，输出其中最小的k个。
>
> 本题有多组输入样例，请使用循环读入，比如while(cin>>)等方式处理
>
> ### 输入描述：
>
> 第一行输入两个整数n和k
> 第二行输入一个整数数组
>
> ### 输出描述：
>
> 输出一个从小到大排序的整数数组
>
> ## 示例1
>
> 输入：
>
> ```
> 5 2
> 1 3 5 7 2
> ```
>
> 复制
>
> 输出：
>
> ```
> 1 2
> ```

```java
import java.util.*;
import java.lang.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNextInt()){
            int number1 = scanner.nextInt();
            int number2 = scanner.nextInt();
            int[] nums = new int[number1];
            for(int i=0;i<number1;i++){
                nums[i] = scanner.nextInt();
            }
            for(int i=0;i<number1;i++){
                for(int j=i+1;j<number1;j++){
                    if(nums[i] > nums[j]){
                        int temp = nums[i];
                        nums[i] = nums[j];
                        nums[j] = temp;
                    }
                }
            }
            for(int i=0;i<number2;i++){
                System.out.print(nums[i] + " ");
            }
            System.out.println();
        }
    }
}
```

## 53.HJ31 单词倒排

> ## 描述
>
> 对字符串中的所有单词进行倒排。
>
> 说明：
>
> 1、构成单词的字符只有26个大写或小写英文字母；
>
> 2、非构成单词的字符均视为单词间隔符；
>
> 3、要求倒排后的单词间隔符以一个空格表示；如果原字符串中相邻单词间有多个间隔符时，倒排转换后也只允许出现一个空格间隔符；
>
> 4、每个单词最长20个字母；
>
> ### 输入描述：
>
> 输入一行以空格来分隔的句子
>
> ### 输出描述：
>
> 输出句子的逆序
>
> ## 示例1
>
> 输入：
>
> ```
> I am a student
> ```
>
> 复制
>
> 输出：
>
> ```
> student a am I
> ```
>
> 复制
>
> ## 示例2
>
> 输入：
>
> ```
> $bo*y gi!r#l
> ```
>
> 复制
>
> 输出：
>
> ```
> l r gi y bo
> ```

```java
import java.util.*;
import java.lang.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNext()){
            String str = scanner.nextLine();
            List<String> result = new ArrayList();
            String temp = "";
            for(int i=0;i<str.length();i++){
                if(Character.isLetter(str.charAt(i))){
                    temp += String.valueOf(str.charAt(i));
                    if(i == str.length()-1){
                        result.add(temp);
                        temp= "";
                    }
                }else{
                    if(!"".equals(temp)){
                        result.add(temp);
                        temp= "";
                    }
                }
            }
            for(int i=result.size()-1;i>=0;i--){
                System.out.print(result.get(i) + " ");
            }
            System.out.println();
        }
    }
}
```

## 54.HJ105 记负均正II

> ## 描述
>
> 从输入任意个整型数，统计其中的负数个数并求所有非负数的平均值，结果保留一位小数，如果没有非负数，则平均值为0
>
> 本题有多组输入数据，输入到文件末尾，请使用while(cin>>)读入
>
> 数据范围小于1e6
>
> ### 输入描述：
>
> 输入任意个整数，每行输入一个。
>
> ### 输出描述：
>
> 输出负数个数以及所有非负数的平均值
>
> ## 示例1
>
> 输入：
>
> ```
> -13
> -4
> -7
> ```
>
> 复制
>
> 输出：
>
> ```
> 3
> 0.0
> ```

```java
import java.util.*;
import java.lang.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        int minus = 0;
        int postive = 0;
        int positveCount = 0;
        double result = 0.0d;
        while(scanner.hasNext()){
            int number = scanner.nextInt();
            if(number >0){
                postive++;
                positveCount += number;
            }else{
                minus++;
            }
        }
        System.out.println(minus);
        if(postive == 0){
            System.out.println("0.0");
        }else{
            result = (double)positveCount / (double)postive;
            System.out.println(String.format("%.1f", result));
        }
    }
}
```

## 55.输入整型数组和排序标识，对其元素按照升序或降序进行排序

> ## 描述
>
> 输入整型数组和排序标识，对其元素按照升序或降序进行排序（一组测试用例可能会有多组数据）
>
> 本题有多组输入，请使用while(cin>>)处理
>
> ### 输入描述：
>
> 第一行输入数组元素个数
> 第二行输入待排序的数组，每个数用空格隔开
> 第三行输入一个整数0或1。0代表升序排序，1代表降序排序
>
> ### 输出描述：
>
> 输出排好序的数字
>
> ## 示例1
>
> 输入：
>
> ```
> 8
> 1 2 4 9 3 55 64 25
> 0
> 5
> 1 2 3 4 5
> 1
> ```
>
> 复制
>
> 输出：
>
> ```
> 1 2 3 4 9 25 55 64
> 5 4 3 2 1
> ```

```java
import java.util.*;
import java.lang.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNextInt()){
            int size = scanner.nextInt();
            int[] data = new int[size];
            for(int i=0;i<size;i++){
                data[i] = scanner.nextInt();
            }
            int f = scanner.nextInt();
            for(int i=0;i<size;i++){
                for(int j = i+1;j<size;j++){
                    if(f == 0){
                         if(data[j] < data[i]){
                             int temp = data[i];
                             data[i] = data[j];
                             data[j] = temp;
                         }
                    }else{
                        if(data[j] > data[i]){
                             int temp = data[i];
                             data[i] = data[j];
                             data[j] = temp;
                         }
                    }
                }
            }
            for(int i=0;i<size;i++){
                System.out.print(data[i] + " ");
            }
            System.out.println();
        }
    }
}
```

## 56.HJ97 记负均正

> ## 描述
>
> 首先输入要输入的整数个数n，然后输入n个整数。输出为n个整数中负数的个数，和所有正整数的平均值，结果保留一位小数。
>
> 本题有多组输入用例。
>
> ### 输入描述：
>
> 首先输入一个正整数n，
> 然后输入n个整数。
>
> ### 输出描述：
>
> 输出负数的个数，和所有正整数的平均值。
>
> ## 示例1
>
> 输入：
>
> ```
> 5
> 1 2 3 4 5
> ```
>
> 复制
>
> 输出：
>
> ```
> 0 3.0
> ```

```java
import java.util.*;
import java.lang.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNextInt()){
            int size = scanner.nextInt();
            int minus = 0;
            int number = 0;
            int numberCount = 0;
            double result = 0.0d;
            for(int i=0;i<size;i++){
                int n = scanner.nextInt();
                if(n<0){
                    minus++;
                }else if(n>0){
                    number++;
                    numberCount+=n;
                }
            }
            System.out.print(minus +" ");
            if(number == 0){
                System.out.println("0.0");
            }else{
                result = (double)numberCount / (double)number;
                System.out.println( String.format("%.1f", result));
            }
            
        }
    }
}
```

## 57.HJ9 提取不重复的整数

> ## 描述
>
> 输入一个int型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数。
>
> 保证输入的整数最后一位不是0。
>
> ### 输入描述：
>
> 输入一个int型整数
>
> ### 输出描述：
>
> 按照从右向左的阅读顺序，返回一个不含重复数字的新的整数
>
> ## 示例1
>
> 输入：
>
> ```
> 9876673
> ```
>
> 复制
>
> 输出：
>
> ```
> 37689
> ```

```java
import java.util.*;
import java.lang.*;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNextInt()){
            int number = scanner.nextInt();
            String result = "";
            String str = String.valueOf(number);
            for(int i=str.length()-1;i>=0;i--){
                char c = str.charAt(i);
                if(!result.contains(String.valueOf(c))){
                    result += c;
                }
            }
            System.out.println(result);
        }
    }
}
```

